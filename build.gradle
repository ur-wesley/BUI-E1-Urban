plugins {
    id 'base'
}

import groovy.json.JsonOutput
import java.time.Instant

def srcDir   = file('src')
def outDir   = file("$buildDir/out")
def pageSize = (findProperty('pageSize') ?: '100') as int

ext {
    booksData = [:]
}

def normalize = { title ->
    title.replaceAll(/\W+/, '_').replaceAll(/^_+|_+$/, '')
}

tasks.register('prepare') {
    description = 'Ensure src/ exists'
    doLast {
        if (!srcDir.exists()) throw new GradleException("src/ not found")
        outDir.deleteDir()
        booksData.clear()
    }
}

tasks.register('parseBooks') {
    description = 'lese jede MD Dateo: erstelle Titel und Kapitel'
    dependsOn 'prepare'
    doLast {
        srcDir.eachFileMatch(~/.+\.md/) { f ->
            def lines = f.readLines('UTF-8')
            def title = lines.find{ it.startsWith('# ') }
                          ?.substring(2)?.trim() ?: f.name
            def chaps = []
            def curr = null
            lines.each { l ->
                if (l.startsWith('## ')) {
                    if (curr) chaps << curr
                    curr = [ title: l.substring(3).trim(), text: [] ]
                } else if (curr) {
                    curr.text << l
                }
            }
            if (curr) chaps << curr
            if (chaps.empty) throw new GradleException("keine Kapitel in ${f.name}")
            booksData[f.name] = [ title: title, chapters: chaps ]
            println "Kapitel - ${f.name}: ${chaps.size()}"
        }
    }
}

tasks.register('splitPages') {
    description = 'erstelle Seiten'
    dependsOn 'parseBooks'
    doLast {
        booksData.each { fname, data ->
            def bookOut = new File(outDir, fname.replaceFirst(/\.md$/, ''))
            bookOut.mkdirs()
            data.chapters.each { chap ->
                def dirName = normalize(chap.title)
                def chapDir = new File(bookOut, dirName); chapDir.mkdirs()
                def txt   = chap.text.join(' ')
                                .replaceAll(/\s+/, ' ').trim()
                def len   = txt.length()
                def words = txt.tokenize(' ')
                def pages = []
                def buf = new StringBuilder()
                words.each { w ->
                    if (buf.size() + w.length() + 1 > pageSize && buf.size()>0) {
                        pages << buf.toString().trim()
                        buf = new StringBuilder()
                    }
                    buf.append(w).append(' ')
                }
                if (buf.size()) pages << buf.toString().trim()
                pages.eachWithIndex { pg, i ->
                    new File(chapDir, "page-${i+1}.md").text = pg + '\n'
                }
                chap.meta = [ dir: dirName, pages: pages.size(), chars: len ]
                println "${data.title} > ${chap.title}: ${pages.size()} seiten"
            }
        }
    }
}

tasks.register('writeMetadata') {
    description = 'Schreibe metadata.json'
    dependsOn 'splitPages'
    doLast {
        booksData.each { fname, data ->
            def bookOut    = new File(outDir, fname.replaceFirst(/\.md$/, ''))
            def totalPages = data.chapters.sum { it.meta.pages }
            def totalChars = data.chapters.sum { it.meta.chars }
            def meta = [
                title      : data.title,
                generated  : Instant.now().toString(),
                pageSize   : pageSize,
                totalPages : totalPages,
                totalChars : totalChars,
                chapters   : data.chapters.collect {
                    [ title: it.title ] + it.meta
                }
            ]
            new File(bookOut, 'metadata.json').text = 
                JsonOutput.prettyPrint(JsonOutput.toJson(meta))
            println "metadata.json erstellt"
        }
    }
}

tasks.register('writeToc') {
    description = 'schreibe inhaltsverzeichnis'
    dependsOn 'splitPages'
    doLast {
        booksData.each { fname, data ->
            def bookOut = new File(outDir, fname.replaceFirst(/\.md$/, ''))
            new File(bookOut, 'toc.md').withWriter('UTF-8') { w ->
                w.println "# Inhaltsverzeichnis: ${data.title}\n"
                data.chapters.each { c ->
                    w.println "## ${c.title}"
                    (1..c.meta.pages).each { p ->
                        w.println "- [Seite ${p}](./${c.meta.dir}/page-${p}.md)"
                    }
                    w.println ''
                }
            }
            println "${data.title}: TOC geschrieben"
        }
    }
}

tasks.register('all') {
    dependsOn 'writeMetadata', 'writeToc'
}

clean.doLast {
    delete outDir
}