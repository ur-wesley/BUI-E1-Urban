plugins {
    id 'base'
}

import groovy.json.JsonOutput

def srcDir   = file('src')
def outDir   = file("$buildDir/out")
def pageSize = (findProperty('pageSize') ?: '100') as int

ext {
    booksData = [:]
}

def normalize = { title ->
    title.replaceAll(/\W+/, '_').replaceAll(/^_+|_+$/, '')
}

tasks.register('prepare') {
    description = 'Ensure src/ exists'
    doLast {
        if (!srcDir.exists()) throw new GradleException("src/ not found")
        outDir.deleteDir()
        booksData.clear()
    }
}

tasks.register('parseBooks') {
    description = 'lese jede MD Dateo: erstelle Titel und Kapitel'
    dependsOn 'prepare'
    inputs.dir srcDir
    outputs.upToDateWhen { false }
    doLast {
        srcDir.eachFileMatch(~/.+\.md/) { f ->
            def lines = f.readLines('UTF-8')
            def title = lines.find{ it.startsWith('# ') }
                          ?.substring(2)?.trim() ?: f.name
            def chaps = []
            def curr = null
            lines.each { l ->
                if (l.startsWith('## ')) {
                    if (curr) chaps << curr
                    curr = [ title: l.substring(3).trim(), text: [] ]
                } else if (curr) {
                    curr.text << l
                }
            }
            if (curr) chaps << curr
            if (chaps.empty) throw new GradleException("keine Kapitel in ${f.name}")
            booksData[f.name] = [ title: title, chapters: chaps ]
            println "Kapitel - ${f.name}: ${chaps.size()}"
        }
    }
}

tasks.register('splitPages') {
    description = 'erstelle Seiten'
    dependsOn 'parseBooks'
    outputs.dir outDir
    doLast {
        booksData.each { fname, data ->
            def bookOut = new File(outDir, fname.replaceFirst(/\.md$/, ''))
            bookOut.mkdirs()
            data.chapters.each { chap ->
                def dirName = normalize(chap.title)
                def chapDir = new File(bookOut, dirName); chapDir.mkdirs()
                def txt = chap.text.join(' ').replaceAll(/\s+/, ' ').trim()
                def len = txt.length()
                def pages = (int)Math.ceil(len / pageSize as double)
                (0..<pages).each { i ->
                    def s = i * pageSize
                    def e = Math.min(s + pageSize, len)
                    new File(chapDir, "page-${i+1}.md")
                        .text = txt.substring(s, e) + '\n'
                }
                chap.meta = [ dir: dirName, pages: pages, chars: len ]
                println "${data.title} â€º ${chap.title}: ${pages} seiten"
            }
        }
    }
}

tasks.register('writeMetadata') {
    description = 'Schreibe metadata.json'
    dependsOn 'splitPages'
    doLast {
        booksData.each { fname, data ->
            def bookOut = new File(outDir, fname.replaceFirst(/\.md$/, ''))
            def total = data.chapters.sum { it.meta.pages }
            def meta = [
                title      : data.title,
                pageSize   : pageSize,
                totalPages : total,
                chapters   : data.chapters.collect {
                    [ title: it.title ] + it.meta
                }
            ]
            new File(bookOut, 'metadata.json').text = 
                JsonOutput.prettyPrint(JsonOutput.toJson(meta))
            println "metadata.json erstellt"
        }
    }
}

tasks.register('writeToc') {
    description = 'schreibe inhaltsverzeichnis'
    dependsOn 'splitPages'
    doLast {
        booksData.each { fname, data ->
            def bookOut = new File(outDir, fname.replaceFirst(/\.md$/, ''))
            new File(bookOut, 'toc.md').withWriter('UTF-8') { w ->
                w.println "# Inhaltsverzeichnis: ${data.title}\n"
                data.chapters.each { c ->
                    w.println "## ${c.title}"
                    (1..c.meta.pages).each { p ->
                        w.println "- [Seite ${p}](./${c.meta.dir}/page-${p}.md)"
                    }
                    w.println ''
                }
            }
            println "${data.title}: TOC geschrieben"
        }
    }
}

tasks.register('all') {
    dependsOn 'writeMetadata', 'writeToc'
}

clean.doLast {
    delete outDir
}